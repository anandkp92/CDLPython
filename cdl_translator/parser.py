"""CXF JSON Parser

Parses Control eXchange Format (CXF) JSON files generated by modelica-json
into CDLModel internal representation.

CXF Format:
- Uses JSON-LD with @context, @graph, @id, @type
- Supports both simple format and S231P namespace format
- S231P format uses namespace prefix on all properties
- Blocks have hasInput, hasOutput, hasParameter, containsBlock properties
- Connections specified via connectedTo or isConnectedTo property on ports
- Instance names use # separator: ModelName#instanceName
"""

import json
from pathlib import Path
from typing import Dict, Any, List, Optional, Union
from cdl_translator.model import (
    CDLModel,
    ModelMetadata,
    BlockInstance,
    Connection,
    Parameter,
    Port,
    PortType,
)


class CXFParser:
    """Parser for CXF JSON files

    Converts CXF JSON (generated by modelica-json) to CDLModel
    internal representation for code generation.

    Supports both simple format and S231P namespace format.
    """

    def __init__(self):
        """Initialize parser"""
        self.id_map = {}  # Map of @id to object for S231P format

    def _map_enum_reference(self, value: str) -> str:
        """Map Modelica enum reference to Python enum reference

        Args:
            value: Modelica enum reference like "Buildings.Controls.OBC.CDL.Types.SimpleController.PI"

        Returns:
            Python enum reference like "SimpleController.PI" or original value if not an enum
        """
        # Enum type mappings: Modelica path prefix -> Python enum class
        enum_mappings = {
            'Buildings.Controls.OBC.CDL.Types.SimpleController': 'SimpleController',
            'Buildings.Controls.OBC.ASHRAE.G36.Types.OperationModes': 'OperationModes',
            'Buildings.Controls.OBC.CDL.Types.Extrapolation': 'Extrapolation',
            'Buildings.Controls.OBC.CDL.Types.Smoothness': 'Smoothness',
            'Buildings.Controls.OBC.CDL.Types.ZeroTime': 'ZeroTime',
        }

        # Check if this looks like an enum reference (has multiple dots)
        if not isinstance(value, str) or value.count('.') < 2:
            return value

        # Try to match enum type prefix
        for modelica_prefix, python_enum in enum_mappings.items():
            if value.startswith(modelica_prefix + '.'):
                # Extract the enum value (last part)
                enum_value = value[len(modelica_prefix) + 1:]
                return f"{python_enum}.{enum_value}"

        # Not a recognized enum, return as-is
        return value

    def _get_prop(self, obj: Dict[str, Any], prop_name: str, default: Any = None) -> Any:
        """Get property with or without S231P namespace

        Tries S231P:propertyName first, then propertyName.

        Args:
            obj: Object dictionary
            prop_name: Property name without namespace
            default: Default value if not found

        Returns:
            Property value or default
        """
        # Try with S231P namespace
        if f"S231P:{prop_name}" in obj:
            return obj[f"S231P:{prop_name}"]
        # Try without namespace
        if prop_name in obj:
            return obj[prop_name]
        return default

    def _extract_id_name(self, id_str: str) -> str:
        """Extract name from @id URI

        Args:
            id_str: @id URI like "http://example.org#FromModelica.Block1"

        Returns:
            Name part after # (e.g., "FromModelica.Block1")
        """
        if '#' in id_str:
            return id_str.split('#')[1]
        return id_str

    def _extract_simple_name(self, id_str: str) -> str:
        """Extract simple name from @id URI

        Args:
            id_str: @id URI like "http://example.org#FromModelica.CustomPWithLimiter"

        Returns:
            Last part of name (e.g., "CustomPWithLimiter")
        """
        full_name = self._extract_id_name(id_str)
        if '.' in full_name:
            return full_name.split('.')[-1]
        return full_name

    def _extract_block_type(self, type_uri: str) -> str:
        """Extract CDL block type from URI

        Args:
            type_uri: Full URI like
                      "http://example.org#Buildings.Controls.OBC.CDL.Reals.Min"

        Returns:
            CDL type: "Buildings.Controls.OBC.CDL.Reals.Min"
        """
        return self._extract_id_name(type_uri)

    def _build_id_map(self, cxf_data: Dict[str, Any]) -> Dict[str, Dict]:
        """Build map of @id to object for resolution

        Args:
            cxf_data: CXF dictionary

        Returns:
            Dictionary mapping @id to object
        """
        id_map = {}

        # Check if @graph exists
        if '@graph' in cxf_data:
            for obj in cxf_data['@graph']:
                if '@id' in obj:
                    id_map[obj['@id']] = obj
        # Also map the root object if it has @id
        elif '@id' in cxf_data:
            id_map[cxf_data['@id']] = cxf_data

        return id_map

    def _resolve_ref(self, ref: Union[str, Dict], default: Any = None) -> Any:
        """Resolve @id reference

        Args:
            ref: Either a string @id or dict with @id
            default: Default value if not found

        Returns:
            Resolved object or default
        """
        # Extract @id
        if isinstance(ref, dict) and '@id' in ref:
            ref_id = ref['@id']
        elif isinstance(ref, str):
            ref_id = ref
        else:
            return default

        # Resolve from id_map
        return self.id_map.get(ref_id, default)

    def parse_file(self, cxf_path: str) -> CDLModel:
        """Parse CXF JSON file into CDLModel

        Args:
            cxf_path: Path to CXF JSON file

        Returns:
            CDLModel representation

        Raises:
            FileNotFoundError: If file doesn't exist
            ValueError: If JSON is invalid or missing required fields
        """
        path = Path(cxf_path)
        if not path.exists():
            raise FileNotFoundError(f"CXF file not found: {cxf_path}")

        with open(path, 'r') as f:
            cxf_data = json.load(f)

        return self.parse_dict(cxf_data)

    def parse_dict(self, cxf_data: Dict[str, Any]) -> CDLModel:
        """Parse CXF data from dictionary

        Args:
            cxf_data: CXF data as dictionary

        Returns:
            CDLModel representation

        Raises:
            ValueError: If data is invalid or missing required fields
        """
        self._validate_cxf(cxf_data)

        # Build @id resolution map for S231P format
        self.id_map = self._build_id_map(cxf_data)

        # Extract main model data
        # S231P format can have @graph or be root object
        if '@graph' in cxf_data:
            # Find main block (should be first or has S231P:Block type)
            model_data = None
            for obj in cxf_data['@graph']:
                obj_type = obj.get('@type', '')
                if 'Block' in obj_type:
                    model_data = obj
                    break
            if model_data is None:
                model_data = cxf_data['@graph'][0]
        else:
            # Root object is the model
            model_data = cxf_data

        # Parse components
        metadata = self._parse_metadata(model_data)
        instances = self._parse_instances(model_data)
        connections = self._parse_connections(model_data, instances)

        model = CDLModel(
            metadata=metadata,
            instances=instances,
            connections=connections
        )

        # Validate generated model
        is_valid, errors = model.validate()
        if not is_valid:
            raise ValueError(f"Generated model invalid: {'; '.join(errors)}")

        return model

    def _parse_metadata(self, model_data: Dict[str, Any]) -> ModelMetadata:
        """Extract model metadata

        Args:
            model_data: Model dictionary from CXF

        Returns:
            ModelMetadata
        """
        # Extract model name from @id or label
        if '@id' in model_data:
            model_name = self._extract_simple_name(model_data['@id'])
        else:
            model_name = self._get_prop(model_data, 'label', 'UnnamedModel')

        # Get description (can be in description or documentation)
        description = self._get_prop(model_data, 'description', '')
        if not description:
            description = self._get_prop(model_data, 'documentation', '')

        # Parse parameters
        parameters = []
        has_param = self._get_prop(model_data, 'hasParameter')
        if has_param:
            # Can be single parameter or list
            param_list = has_param if isinstance(has_param, list) else [has_param]
            for param_ref in param_list:
                # Resolve reference if needed
                param_data = self._resolve_ref(param_ref, param_ref)
                if param_data and isinstance(param_data, dict):
                    param = self._parse_parameter(param_data)
                    parameters.append(param)

        # Parse inputs
        inputs = []
        has_input = self._get_prop(model_data, 'hasInput')
        if has_input:
            # Can be single input or list
            input_list = has_input if isinstance(has_input, list) else [has_input]
            for input_ref in input_list:
                # Resolve reference if needed
                input_data = self._resolve_ref(input_ref, input_ref)
                if input_data and isinstance(input_data, dict):
                    port = self._parse_port(input_data, model_name)
                    inputs.append(port)

        # Parse outputs
        outputs = []
        has_output = self._get_prop(model_data, 'hasOutput')
        if has_output:
            # Can be single output or list
            output_list = has_output if isinstance(has_output, list) else [has_output]
            for output_ref in output_list:
                # Resolve reference if needed
                output_data = self._resolve_ref(output_ref, output_ref)
                if output_data and isinstance(output_data, dict):
                    port = self._parse_port(output_data, model_name)
                    outputs.append(port)

        return ModelMetadata(
            name=model_name,
            description=description,
            parameters=parameters,
            inputs=inputs,
            outputs=outputs
        )

    def _parse_instances(self, model_data: Dict[str, Any]) -> List[BlockInstance]:
        """Extract block instances

        Args:
            model_data: Model dictionary from CXF

        Returns:
            List of BlockInstance
        """
        instances = []

        contains_block = self._get_prop(model_data, 'containsBlock')
        if not contains_block:
            return instances

        # Ensure it's a list
        block_list = contains_block if isinstance(contains_block, list) else [contains_block]

        for block_ref in block_list:
            # Resolve reference to get actual block data
            block_data = self._resolve_ref(block_ref, block_ref)
            if not block_data or not isinstance(block_data, dict):
                continue

            # Extract instance name from @id or label
            if '@id' in block_data:
                full_id = self._extract_id_name(block_data['@id'])
                # Instance name is the last part after last dot
                if '.' in full_id:
                    instance_name = full_id.split('.')[-1]
                else:
                    instance_name = full_id
            else:
                instance_name = self._get_prop(block_data, 'label', 'unnamed')

            # Extract block type from @type
            block_type_raw = block_data.get('@type', '')
            block_type = self._extract_block_type(block_type_raw)

            # Parse parameters from hasInstance
            parameters = {}
            has_instance = self._get_prop(block_data, 'hasInstance')
            if has_instance:
                # Ensure it's a list
                instance_list = has_instance if isinstance(has_instance, list) else [has_instance]
                for inst_ref in instance_list:
                    inst_data = self._resolve_ref(inst_ref, inst_ref)
                    if not inst_data or not isinstance(inst_data, dict):
                        continue

                    # Check if this is a parameter (has value property)
                    if 'S231P:value' in inst_data or 'value' in inst_data:
                        param = self._parse_parameter(inst_data)
                        # Handle parameter references
                        value = param.value
                        if isinstance(value, str) and not value.replace('.', '').replace('-', '').replace('e', '').replace('+', '').replace('E', '').replace('_', '').isdigit():
                            # Looks like a reference, not a number
                            # First try to map as enum reference
                            mapped_value = self._map_enum_reference(value)
                            if mapped_value != value:
                                # Successfully mapped to enum
                                value = mapped_value
                            elif '.' not in value or value in self.id_map:
                                # Simple name - reference to parent parameter
                                # Handle negation or other unary operators
                                if value.startswith('-'):
                                    # Negated parameter: -paramName -> -self.paramName
                                    value = f"-self.{value[1:]}"
                                elif value.startswith('+'):
                                    # Positive parameter: +paramName -> +self.paramName (rare but handle it)
                                    value = f"+self.{value[1:]}"
                                else:
                                    value = f"self.{value}"
                        parameters[param.name] = value

            instance = BlockInstance(
                instance_name=instance_name,
                block_type=block_type,
                parameters=parameters
            )
            instances.append(instance)

        return instances

    def _parse_connections(
        self,
        model_data: Dict[str, Any],
        instances: List[BlockInstance]
    ) -> List[Connection]:
        """Extract connections from port connectedTo properties

        Args:
            model_data: Model dictionary from CXF @graph
            instances: List of parsed block instances

        Returns:
            List of Connection
        """
        connections = []
        model_name = self._extract_simple_name(model_data.get('@id', ''))

        # Extract all port connections
        port_connections = self._extract_port_connections(model_data)

        # Convert port connections to Connection objects
        for port_id, connected_to, is_input_port in port_connections:
            # Connection semantics:
            # S231P format (isConnectedTo): port with connection is always the SOURCE
            #   - port -> isConnectedTo (always this direction)
            # Old format (connectedTo): depends on port type
            #   - INPUT connectedTo X: X -> INPUT (X is source)
            #   - OUTPUT connectedTo Y: OUTPUT -> Y (OUTPUT is source)

            # Detect format by checking if port is model-level or block-level
            port_block, _ = self._parse_port_id(port_id, model_name)
            connected_block, _ = self._parse_port_id(connected_to, model_name)

            # S231P format: model-level ports have isConnectedTo (port is source)
            # Old format: only block-level ports have connectedTo
            if port_block is None:
                # Model-level port with connection -> S231P format
                # Port is source, connectedTo is target
                source_block, source_port = self._parse_port_id(port_id, model_name)
                target_block, target_port = self._parse_port_id(connected_to, model_name)
            elif connected_block is None:
                # Block-level port connected to model port -> Old format
                # For inputs: connected (model) is source, port (block) is target
                # For outputs: port (block) is source, connected (model) is target
                if is_input_port:
                    source_block, source_port = self._parse_port_id(connected_to, model_name)
                    target_block, target_port = self._parse_port_id(port_id, model_name)
                else:
                    source_block, source_port = self._parse_port_id(port_id, model_name)
                    target_block, target_port = self._parse_port_id(connected_to, model_name)
            else:
                # Block-to-block connection (both formats use same semantics)
                # Port with connection is source
                source_block, source_port = self._parse_port_id(port_id, model_name)
                target_block, target_port = self._parse_port_id(connected_to, model_name)

            connection = Connection(
                source_block=source_block,
                source_port=source_port,
                target_block=target_block,
                target_port=target_port
            )
            connections.append(connection)

        return connections

    def _extract_port_connections(self, block_data: Dict[str, Any]) -> List[tuple[str, str, bool]]:
        """Recursively extract all port connections from block

        Args:
            block_data: Block dictionary

        Returns:
            List of tuples: (port_id, connectedTo_id, is_input_port)
            is_input_port indicates if the port is an input (affects connection direction)
        """
        # Use list to collect all connections (including multiple from same port)
        connections_list = []
        # Track seen connections to avoid duplicates
        seen = set()

        # Helper to extract connection from port object
        def extract_connection(port_obj, is_input):
            if not isinstance(port_obj, dict):
                return
            # Resolve if it's a reference
            port_data = self._resolve_ref(port_obj, port_obj)
            if not port_data or '@id' not in port_data:
                return

            port_id = port_data['@id']

            # Check for connectedTo or isConnectedTo
            connected = self._get_prop(port_data, 'connectedTo') or self._get_prop(port_data, 'isConnectedTo')
            if connected:
                # Handle list of connections (port connected to multiple targets)
                if isinstance(connected, list):
                    for conn_item in connected:
                        if isinstance(conn_item, dict) and '@id' in conn_item:
                            target_id = conn_item['@id']
                        elif isinstance(conn_item, str):
                            target_id = conn_item
                        else:
                            continue
                        # Add if not already seen
                        conn_tuple = (port_id, target_id, is_input)
                        if conn_tuple not in seen:
                            connections_list.append(conn_tuple)
                            seen.add(conn_tuple)
                else:
                    # Single connection
                    if isinstance(connected, dict) and '@id' in connected:
                        target_id = connected['@id']
                    elif isinstance(connected, str):
                        target_id = connected
                    else:
                        return

                    # Add if not already seen
                    conn_tuple = (port_id, target_id, is_input)
                    if conn_tuple not in seen:
                        connections_list.append(conn_tuple)
                        seen.add(conn_tuple)

        # Check inputs - for inputs, connectedTo/isConnectedTo is the SOURCE
        has_input = self._get_prop(block_data, 'hasInput')
        if has_input:
            input_list = has_input if isinstance(has_input, list) else [has_input]
            for input_obj in input_list:
                extract_connection(input_obj, True)

        # Check outputs - for outputs, connectedTo/isConnectedTo is the TARGET
        has_output = self._get_prop(block_data, 'hasOutput')
        if has_output:
            output_list = has_output if isinstance(has_output, list) else [has_output]
            for output_obj in output_list:
                extract_connection(output_obj, False)

        # Check hasInstance (used by contained blocks to list their ports)
        has_instance = self._get_prop(block_data, 'hasInstance')
        if has_instance:
            instance_list = has_instance if isinstance(has_instance, list) else [has_instance]
            for instance_obj in instance_list:
                instance_data = self._resolve_ref(instance_obj, instance_obj)
                if instance_data and isinstance(instance_data, dict):
                    # Determine if this is an input or output by checking @type
                    inst_type = instance_data.get('@type', '')
                    is_input = 'Input' in inst_type
                    # Extract connection regardless of input/output
                    extract_connection(instance_data, is_input)

        # Recursively check contained blocks
        contains_block = self._get_prop(block_data, 'containsBlock')
        if contains_block:
            block_list = contains_block if isinstance(contains_block, list) else [contains_block]
            for block_ref in block_list:
                block_obj = self._resolve_ref(block_ref, block_ref)
                if block_obj and isinstance(block_obj, dict):
                    sub_connections = self._extract_port_connections(block_obj)
                    # Merge sub-connections into our list (avoiding duplicates)
                    for conn_tuple in sub_connections:
                        if conn_tuple not in seen:
                            connections_list.append(conn_tuple)
                            seen.add(conn_tuple)

        return connections_list

    def _parse_port_id(
        self,
        port_id: str,
        model_name: str
    ) -> tuple[Optional[str], str]:
        """Parse port ID into (block_name, port_name)

        Args:
            port_id: Port ID (e.g., "http://example.org#Model.block.port" or "Model#port")
            model_name: Model name for identifying model-level ports (simple name)

        Returns:
            Tuple of (block_name or None, port_name)
            None for block_name indicates model-level input/output
        """
        # Extract name part after #
        full_name = self._extract_id_name(port_id)

        # S231P format examples:
        # - "FromModelica.CustomPWithLimiter.e" -> model port "e"
        # - "FromModelica.CustomPWithLimiter.gain.u" -> block "gain" port "u"

        parts = full_name.split('.')
        port_name = parts[-1]

        if len(parts) == 1:
            # Just "portName" - model port
            return (None, port_name)
        elif len(parts) == 2:
            # "instance.portName" or "ModelName.portName"
            # Assume instance.portName (old format)
            # Unless second-to-last is the model name
            if parts[0] == model_name:
                # ModelName.portName - model port
                return (None, port_name)
            else:
                # instance.portName - block port
                return (parts[0], port_name)
        else:
            # 3+ parts: "Package.ModelName.portName" or "Package.ModelName.instance.portName"
            # Check if second-to-last part is the model name
            potential_instance = parts[-2]

            if potential_instance == model_name:
                # This is a model-level port: "Package.ModelName.portName"
                return (None, port_name)
            else:
                # This is a block port: "Package.ModelName.BlockName.portName"
                return (potential_instance, port_name)

    def _parse_parameter(self, param_data: Dict[str, Any]) -> Parameter:
        """Parse parameter from CXF data

        Args:
            param_data: Parameter dictionary

        Returns:
            Parameter object
        """
        # Extract name from @id or label
        if '@id' in param_data:
            full_id = self._extract_id_name(param_data['@id'])
            # Get last part after dot
            param_name = full_id.split('.')[-1] if '.' in full_id else full_id
        else:
            param_name = self._get_prop(param_data, 'label', 'unnamed')

        # Get type from @type or isOfDataType
        param_type_raw = param_data.get('@type', '')
        if 'Parameter' in param_type_raw:
            # Check isOfDataType for actual type
            data_type = self._get_prop(param_data, 'isOfDataType')
            if data_type:
                if isinstance(data_type, dict) and '@id' in data_type:
                    type_id = data_type['@id']
                    param_type = type_id.split(':')[-1] if ':' in type_id else type_id
                else:
                    param_type = str(data_type)
            else:
                param_type = 'Real'
        else:
            param_type = param_type_raw.split(':')[-1] if ':' in param_type_raw else param_type_raw
            if not param_type:
                param_type = 'Real'

        # Get value
        value = self._get_prop(param_data, 'value', 0.0)

        # Map enum references if the value is a string
        if isinstance(value, str):
            value = self._map_enum_reference(value)

        # Get description
        description = self._get_prop(param_data, 'description', '')

        return Parameter(
            name=param_name,
            type=param_type,
            value=value,
            description=description
        )

    def _parse_port(self, port_data: Dict[str, Any], model_name: str) -> Port:
        """Parse port from CXF data

        Args:
            port_data: Port dictionary
            model_name: Model name for extracting port name

        Returns:
            Port object
        """
        # Extract name from @id or label
        if '@id' in port_data:
            full_id = self._extract_id_name(port_data['@id'])
            # Get last part after dot (port name)
            port_name = full_id.split('.')[-1] if '.' in full_id else full_id
        else:
            port_name = self._get_prop(port_data, 'label', 'unnamed')

        # Get type from @type (RealInput, IntegerOutput, etc.)
        type_str = port_data.get('@type', 'RealInput')
        # Remove namespace prefix if present
        if ':' in type_str:
            type_str = type_str.split(':')[-1]

        # Extract base type (Real, Integer, Boolean)
        if 'Real' in type_str:
            port_type = PortType.REAL
        elif 'Integer' in type_str:
            port_type = PortType.INTEGER
        elif 'Boolean' in type_str:
            port_type = PortType.BOOLEAN
        else:
            port_type = PortType.REAL  # Default

        # Get description
        description = self._get_prop(port_data, 'description', '')

        return Port(
            name=port_name,
            type=port_type,
            description=description
        )

    def _validate_cxf(self, cxf_data: Dict[str, Any]) -> bool:
        """Validate CXF structure

        Args:
            cxf_data: CXF dictionary

        Returns:
            True if valid

        Raises:
            ValueError: If validation fails
        """
        # Check for @context (required for JSON-LD)
        if '@context' not in cxf_data:
            raise ValueError("CXF missing required field: @context")

        # CXF can have @graph or be a single object
        if '@graph' in cxf_data:
            # @graph format
            if not isinstance(cxf_data['@graph'], list) or len(cxf_data['@graph']) == 0:
                raise ValueError("CXF @graph must be non-empty list")

            # Find a Block object in @graph
            has_block = False
            for obj in cxf_data['@graph']:
                if '@type' in obj and 'Block' in obj['@type']:
                    has_block = True
                    break

            if not has_block:
                raise ValueError("CXF @graph must contain at least one Block object")
        else:
            # Single object format
            if '@type' not in cxf_data:
                raise ValueError("CXF root object missing @type")

        return True
