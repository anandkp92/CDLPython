"""CXF JSON Parser

Parses Control eXchange Format (CXF) JSON files generated by modelica-json
into CDLModel internal representation.

CXF Format:
- Uses JSON-LD with @context, @graph, @id, @type
- Blocks have hasInput, hasOutput, hasParameter, containsBlock properties
- Connections specified via connectedTo property on ports
- Instance names use # separator: ModelName#instanceName
"""

import json
from pathlib import Path
from typing import Dict, Any, List, Optional
from cdl_translator.model import (
    CDLModel,
    ModelMetadata,
    BlockInstance,
    Connection,
    Parameter,
    Port,
    PortType,
)


class CXFParser:
    """Parser for CXF JSON files

    Converts CXF JSON (generated by modelica-json) to CDLModel
    internal representation for code generation.
    """

    def __init__(self):
        """Initialize parser"""
        pass

    def parse_file(self, cxf_path: str) -> CDLModel:
        """Parse CXF JSON file into CDLModel

        Args:
            cxf_path: Path to CXF JSON file

        Returns:
            CDLModel representation

        Raises:
            FileNotFoundError: If file doesn't exist
            ValueError: If JSON is invalid or missing required fields
        """
        path = Path(cxf_path)
        if not path.exists():
            raise FileNotFoundError(f"CXF file not found: {cxf_path}")

        with open(path, 'r') as f:
            cxf_data = json.load(f)

        return self.parse_dict(cxf_data)

    def parse_dict(self, cxf_data: Dict[str, Any]) -> CDLModel:
        """Parse CXF data from dictionary

        Args:
            cxf_data: CXF data as dictionary

        Returns:
            CDLModel representation

        Raises:
            ValueError: If data is invalid or missing required fields
        """
        self._validate_cxf(cxf_data)

        # Extract main model from @graph
        if '@graph' not in cxf_data or len(cxf_data['@graph']) == 0:
            raise ValueError("CXF missing @graph or empty")

        model_data = cxf_data['@graph'][0]

        # Parse components
        metadata = self._parse_metadata(model_data)
        instances = self._parse_instances(model_data)
        connections = self._parse_connections(model_data, instances)

        model = CDLModel(
            metadata=metadata,
            instances=instances,
            connections=connections
        )

        # Validate generated model
        is_valid, errors = model.validate()
        if not is_valid:
            raise ValueError(f"Generated model invalid: {'; '.join(errors)}")

        return model

    def _parse_metadata(self, model_data: Dict[str, Any]) -> ModelMetadata:
        """Extract model metadata

        Args:
            model_data: Model dictionary from CXF @graph

        Returns:
            ModelMetadata
        """
        # Extract model name from @id
        model_name = model_data.get('@id', 'UnnamedModel')

        # Get description
        description = model_data.get('description', '')

        # Parse parameters
        parameters = []
        if 'hasParameter' in model_data:
            for param_data in model_data['hasParameter']:
                param = self._parse_parameter(param_data)
                parameters.append(param)

        # Parse inputs
        inputs = []
        if 'hasInput' in model_data:
            for input_data in model_data['hasInput']:
                port = self._parse_port(input_data, model_name)
                inputs.append(port)

        # Parse outputs
        outputs = []
        if 'hasOutput' in model_data:
            for output_data in model_data['hasOutput']:
                port = self._parse_port(output_data, model_name)
                outputs.append(port)

        return ModelMetadata(
            name=model_name,
            description=description,
            parameters=parameters,
            inputs=inputs,
            outputs=outputs
        )

    def _parse_instances(self, model_data: Dict[str, Any]) -> List[BlockInstance]:
        """Extract block instances

        Args:
            model_data: Model dictionary from CXF @graph

        Returns:
            List of BlockInstance
        """
        instances = []

        if 'containsBlock' not in model_data:
            return instances

        for block_data in model_data['containsBlock']:
            # Extract instance name from @id (format: ModelName#instanceName)
            block_id = block_data.get('@id', '')
            if '#' in block_id:
                instance_name = block_id.split('#')[1]
            else:
                instance_name = block_id

            # Extract block type from @type
            block_type = block_data.get('@type', '')

            # Parse parameters
            parameters = {}
            if 'hasParameter' in block_data:
                for param_data in block_data['hasParameter']:
                    param = self._parse_parameter(param_data)
                    # Handle parameter references (e.g., "@parent.k")
                    value = param.value
                    if isinstance(value, str) and value.startswith('@parent.'):
                        # Reference to parent parameter
                        param_name = value.replace('@parent.', '')
                        value = f"self.{param_name}"
                    parameters[param.name] = value

            instance = BlockInstance(
                instance_name=instance_name,
                block_type=block_type,
                parameters=parameters
            )
            instances.append(instance)

        return instances

    def _parse_connections(
        self,
        model_data: Dict[str, Any],
        instances: List[BlockInstance]
    ) -> List[Connection]:
        """Extract connections from port connectedTo properties

        Args:
            model_data: Model dictionary from CXF @graph
            instances: List of parsed block instances

        Returns:
            List of Connection
        """
        connections = []
        model_name = model_data.get('@id', '')

        # Build map of all ports with their connections
        port_connections = self._extract_port_connections(model_data)

        # Convert port connections to Connection objects
        for port_id, connected_to in port_connections.items():
            # Parse source port
            source_block, source_port = self._parse_port_id(port_id, model_name)

            # Parse target port
            target_block, target_port = self._parse_port_id(connected_to, model_name)

            connection = Connection(
                source_block=source_block,
                source_port=source_port,
                target_block=target_block,
                target_port=target_port
            )
            connections.append(connection)

        return connections

    def _extract_port_connections(self, block_data: Dict[str, Any]) -> Dict[str, str]:
        """Recursively extract all port connections from block

        Args:
            block_data: Block dictionary

        Returns:
            Dictionary mapping port @id to connectedTo @id
        """
        connections = {}

        # Check inputs
        if 'hasInput' in block_data:
            for input_data in block_data['hasInput']:
                if 'connectedTo' in input_data:
                    connections[input_data['@id']] = input_data['connectedTo']

        # Check outputs
        if 'hasOutput' in block_data:
            for output_data in block_data['hasOutput']:
                if 'connectedTo' in output_data:
                    connections[output_data['@id']] = output_data['connectedTo']

        # Recursively check contained blocks
        if 'containsBlock' in block_data:
            for sub_block in block_data['containsBlock']:
                sub_connections = self._extract_port_connections(sub_block)
                connections.update(sub_connections)

        return connections

    def _parse_port_id(
        self,
        port_id: str,
        model_name: str
    ) -> tuple[Optional[str], str]:
        """Parse port ID into (block_name, port_name)

        Args:
            port_id: Port ID (e.g., "Model#block.port" or "Model#port")
            model_name: Model name for identifying model-level ports

        Returns:
            Tuple of (block_name or None, port_name)
            None for block_name indicates model-level input/output
        """
        # Remove model name prefix
        if '#' in port_id:
            port_path = port_id.split('#')[1]
        else:
            port_path = port_id

        # Check if it's a block port (has dot) or model port (no dot)
        if '.' in port_path:
            # Block port: "blockName.portName"
            parts = port_path.split('.')
            return (parts[0], parts[1])
        else:
            # Model-level port: "portName"
            return (None, port_path)

    def _parse_parameter(self, param_data: Dict[str, Any]) -> Parameter:
        """Parse parameter from CXF data

        Args:
            param_data: Parameter dictionary

        Returns:
            Parameter object
        """
        # Extract name from @id
        param_id = param_data.get('@id', '')
        if '.' in param_id:
            param_name = param_id.split('.')[-1]
        elif '#' in param_id:
            param_name = param_id.split('#')[-1]
        else:
            param_name = param_id

        # Get type from @type
        param_type = param_data.get('@type', 'Real')

        # Get value
        value = param_data.get('value', 0.0)

        # Get description
        description = param_data.get('description', '')

        return Parameter(
            name=param_name,
            type=param_type,
            value=value,
            description=description
        )

    def _parse_port(self, port_data: Dict[str, Any], model_name: str) -> Port:
        """Parse port from CXF data

        Args:
            port_data: Port dictionary
            model_name: Model name for extracting port name

        Returns:
            Port object
        """
        # Extract name from @id (format: ModelName#portName)
        port_id = port_data.get('@id', '')
        if '#' in port_id:
            port_name = port_id.split('#')[1]
        else:
            port_name = port_id

        # Remove any block prefix if present
        if '.' in port_name:
            port_name = port_name.split('.')[-1]

        # Get type from @type (RealInput, IntegerOutput, etc.)
        type_str = port_data.get('@type', 'RealInput')
        # Extract base type (Real, Integer, Boolean)
        if 'Real' in type_str:
            port_type = PortType.REAL
        elif 'Integer' in type_str:
            port_type = PortType.INTEGER
        elif 'Boolean' in type_str:
            port_type = PortType.BOOLEAN
        else:
            port_type = PortType.REAL  # Default

        # Get description
        description = port_data.get('description', '')

        return Port(
            name=port_name,
            type=port_type,
            description=description
        )

    def _validate_cxf(self, cxf_data: Dict[str, Any]) -> bool:
        """Validate CXF structure

        Args:
            cxf_data: CXF dictionary

        Returns:
            True if valid

        Raises:
            ValueError: If validation fails
        """
        # Check for required top-level fields
        if '@graph' not in cxf_data:
            raise ValueError("CXF missing required field: @graph")

        if not isinstance(cxf_data['@graph'], list) or len(cxf_data['@graph']) == 0:
            raise ValueError("CXF @graph must be non-empty list")

        model_data = cxf_data['@graph'][0]

        # Check model has @id
        if '@id' not in model_data:
            raise ValueError("Model missing required field: @id")

        # Check model has @type
        if '@type' not in model_data:
            raise ValueError("Model missing required field: @type")

        return True
